!function(){"use strict";class e{constructor(e="keyval-store",o="keyval"){this.storeName=o,this._dbp=new Promise((t,n)=>{const a=indexedDB.open(e,1);a.onerror=()=>n(a.error),a.onsuccess=()=>t(a.result),a.onupgradeneeded=()=>{a.result.createObjectStore(o)}})}_withIDBStore(e,o){return this._dbp.then(t=>new Promise((n,a)=>{const r=t.transaction(this.storeName,e);r.oncomplete=()=>n(),r.onabort=r.onerror=()=>a(r.error),o(r.objectStore(this.storeName))}))}}let o,t;function n(){return o||(o=new e),o}function a(e,o=n()){let t;return o._withIDBStore("readonly",o=>{t=o.get(e)}).then(()=>t.result)}function r(e,o,t=n()){return t._withIDBStore("readwrite",t=>{t.put(o,e)})}async function s(){let e=performance.now();const o=await fetch("./version",{cache:"no-cache"});let t=performance.now();if(console.log(`perf: checkForUpdates: fetch took ${t-e}ms`),e=t,o.ok){console.log("reading version info...");let n=o.body.getReader();const s=await async function(e,o){e.next();for(;;){let{value:t,done:n}=await o.read();n&&e.throw("driveParserFromReader: endOfStream");for(let o of t){let t=e.next(o);if(t.done)return t.value}}}(function*(){const e=yield*d(),o=yield*function*(){const e=yield,o=yield,t=yield,n=yield;return e|o<<8|t<<16|n<<24}(),t=yield*c();console.log("reading "+t+" files");let n=[];for(let e=0;e<t;e++)n.push(yield*d());return{version:e,size:o,files:n}}(),n);console.log("version info parsed: "+JSON.stringify(s,null,2)),t=performance.now(),console.log(`perf: checkForUpdates: parsing took ${t-e}ms`),e=t;const i=s.version,u=await a("local-version"),f=new Date,p=u!=i;return await r("date-checked",f),await r("update-available",p),await r("update-size",s.size),console.log("local version: "+u+" / upstream version "+i),await l({type:"update-info",status:p?"available":"up-to-date",date_checked:f,update_size:s.size}),t=performance.now(),console.log(`perf: checkForUpdates: updating db and notifying clients took ${t-e}ms`),e=t,s}console.log("retrieving version file failed.")}async function i(){const e=performance.now();await l({type:"serviceworker-info",text:"Updating version info..."});const o=await s(),n=o.version,i=await a("local-version");if(console.log(`local_version: ${i}`),console.log(`upstream_version: ${n}`),i==n)return console.log("versions match, we're all good."),void await l({type:"serviceworker-info",text:"Huh, seems like your local version is already up-to-date..."});console.log("mismatch, updating."),await l({type:"serviceworker-info",text:"Downloading files..."});const c="v1-"+n,d="v1-"+i;let u=await caches.open(c);await u.addAll(o.files),console.log("installNewestVersion: new cache's keys: "+await u.keys()),await l({type:"serviceworker-info",text:"Cleaning up..."}),await r("local-version",n),t=n,await caches.delete(d)?console.log("old cache deleted."):console.log("coulnd't find old cache??"),console.log("perf: installNewestVersion took "+(performance.now()-e)+"ms"),await l({type:"serviceworker-info",text:"Done! Your page should reload now."}),l({type:"update-info",status:"installed",last_checked:new Date})}async function l(e){const o=await clients.matchAll({type:"window"});console.log("notifyClients: posting message "+e+" to "+o.length+" clients.");for(const t of o)t.postMessage(e)}function*c(){return(yield)|(yield)<<8}function*d(){const e=yield*c();let o=new Uint8Array(e);for(let e=0;e<o.length;e++)o[e]=yield;return(new TextDecoder).decode(o)}self.addEventListener("install",e=>{e.waitUntil(async function(){await a("local-version")?await s():await i()}().catch(e=>console.log("Error in setup: "+e+" ("+e.fileName+":"+e.lineNumber+")")))}),self.addEventListener("fetch",e=>{e.respondWith((async e=>{const o=performance.now(),n=await async function(){return t||(console.log("perf: retrieving active cache name from db"),t=await a("local-version")),await caches.open("v1-"+t)}(),s=await n.match(e.request);if(s){const e=performance.now();return console.log("fast path perf: "+(e-o)),s}{const o=new URL(e.request.url).pathname,t=new URL(registration.scope).pathname;if(console.log(`file ${o} not in cache`),o==t){const e=await n.match("/index.html");if(e)return e}else if("reinstall"==o.split("/").slice(-1)[0]){const e="v1-"+await a("local-version");console.log(`deleting cache ${e}`),console.log(await caches.delete(e)),await r("local-version",void 0),await i();const o=new Headers({Location:t+"index.html"}),n=new Response("Done! Please go back to the main page now.",{status:307,statusText:"Redirecting back home",headers:o});return console.log("sent response with headers"),n}const s=new Headers({"Content-Type":"text/html"}),l=new Response('<!DOCTYPE html>\n<html>\n<head>\n<title>File not found</title>\n</head>\n<body>\n<p>The resource you requested was not in our cache. This could be for one of three reasons:</p>\n<ul>\n<li>The resource is part of the app, but we forgot to cache it. In this case, it would be nice if you filed an issue.</li>\n<li>The resource is part of the app, but the browser deleted it from our cache. In this case, please try <a href="./reinstall">re-downloading all relevant files</a>.</li>\n<li>The resource is not part of the app, but you or your browser decided to request it anyway. In this case, there is nothing we can do.</li>\n</ul>\n</body>\n</html>',{status:404,statusText:"Not Found",headers:s});return console.log("Warning: tried to fetch unpackaged resource: "+e.request.url),l}})(e).catch(e=>{console.log("cache lookup error: "+e+" ("+e.fileName+":"+e.lineNumber+")")}))}),self.addEventListener("message",async e=>{if("get-version"==e.data)e.source.postMessage({type:"version-info",serviceworker_version:"friday-lite-0.16"});else if("check-for-updates"==e.data){console.log("hello"),e.source.postMessage({type:"serviceworker-info",text:"Checking..."});try{await s(),e.source.postMessage({type:"serviceworker-info",text:""})}catch(o){e.source.postMessage({type:"serviceworker-info",text:`Sorry, couldn't check for updates. (Error: ${o})`}),console.log("Error in checkForUpdates: "+o+" ("+o.fileName+":"+o.lineNumber+")")}}else if("do-update"==e.data)try{await i()}catch(e){l({type:"serviceworker-info",text:`Sorry, update failed. (Error: ${e})`}),console.log("Error in installNewestVersion: "+e+" ("+e.fileName+":"+e.lineNumber+")")}else if("get-update-info"==e.data){const o=await a("update-available");e.source.postMessage({type:"update-info",status:o?"available":"up-to-date",date_checked:await a("date-checked"),update_size:await a("update-size")})}})}();
//# sourceMappingURL=serviceworker-release.js.map
