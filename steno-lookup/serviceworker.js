!function(){"use strict";class e{constructor(e="keyval-store",t="keyval"){this.storeName=t,this._dbp=new Promise((o,a)=>{const n=indexedDB.open(e,1);n.onerror=()=>a(n.error),n.onsuccess=()=>o(n.result),n.onupgradeneeded=()=>{n.result.createObjectStore(t)}})}_withIDBStore(e,t){return this._dbp.then(o=>new Promise((a,n)=>{const s=o.transaction(this.storeName,e);s.oncomplete=()=>a(),s.onabort=s.onerror=()=>n(s.error),t(s.objectStore(this.storeName))}))}}let t,o;function a(){return t||(t=new e),t}function n(e,t=a()){let o;return t._withIDBStore("readonly",t=>{o=t.get(e)}).then(()=>o.result)}function s(e,t,o=a()){return o._withIDBStore("readwrite",o=>{o.put(t,e)})}async function r(){let e=performance.now();const t=await fetch("./version",{cache:"no-cache"});let o=performance.now();if(console.log(`perf: checkForUpdates: fetch took ${o-e}ms`),e=o,t.ok){console.log("reading version info...");let a=t.body.getReader();const r=await async function(e,t){e.next();for(;;){let{value:o,done:a}=await t.read();a&&e.throw("driveParserFromReader: endOfStream");for(let t of o){let o=e.next(t);if(o.done)return o.value}}}(function*(){const e=yield*d(),t=yield*function*(){const e=yield,t=yield,o=yield,a=yield;return e|t<<8|o<<16|a<<24}(),o=yield*c();console.log("reading "+o+" files");let a=[];for(let e=0;e<o;e++)a.push(yield*d());return{version:e,size:t,files:a}}(),a);console.log("version info parsed: "+JSON.stringify(r,null,2)),o=performance.now(),console.log(`perf: checkForUpdates: parsing took ${o-e}ms`),e=o;const i=r.version,u=await n("local-version"),f=new Date,p=u!=i;return await s("date-checked",f),await s("update-available",p),await s("update-size",r.size),console.log("local version: "+u+" / upstream version "+i),await l({type:"update-info",status:p?"available":"up-to-date",date_checked:f,update_size:r.size}),o=performance.now(),console.log(`perf: checkForUpdates: updating db and notifying clients took ${o-e}ms`),e=o,r}console.log("retrieving version file failed.")}async function i(e=!1){const t=performance.now();await l({type:"serviceworker-info",text:"Updating version info..."});const a=await r(),i=a.version,c=await n("local-version");if(console.log(`local_version: ${c}`),console.log(`upstream_version: ${i}`),c==i)return void console.log("versions match, we're all good.");console.log("mismatch, updating."),await l({type:"serviceworker-info",text:"Downloading files..."});const d="v1-"+i,u="v1-"+c;let f=await caches.open(d);await f.addAll(a.files),console.log("installNewestVersion: new cache's keys: "+await f.keys()),await l({type:"serviceworker-info",text:"Cleaning up..."}),await s("local-version",i),o=i,e?await s("old-cache-name",u):await caches.delete(u)?console.log("old cache deleted."):console.log("coulnd't find old cache??"),console.log("perf: installNewestVersion took "+(performance.now()-t)+"ms"),await l({type:"serviceworker-info",text:"Done! Your page should reload now."}),l({type:"update-info",status:"installed",last_checked:new Date})}async function l(e){const t=await clients.matchAll({type:"window"});console.log("notifyClients: posting message "+e+" to "+t.length+" clients.");for(const o of t)o.postMessage(e)}function*c(){return(yield)|(yield)<<8}function*d(){const e=yield*c();let t=new Uint8Array(e);for(let e=0;e<t.length;e++)t[e]=yield;return(new TextDecoder).decode(t)}self.addEventListener("install",e=>{e.waitUntil(async function(){await n("local-version");await i(!0)}().catch(e=>console.log("Error in setup: "+e+" ("+e.fileName+":"+e.lineNumber+")")))}),self.addEventListener("activate",e=>{e.waitUntil(async function(){console.log("deleted old cache: "+await caches.delete(await n("old-cache-name")))}().catch(e=>{console.log(`Error in setup: ${e} (${e.fileName}:${e.lineNumber})`)}))}),self.addEventListener("fetch",e=>{e.respondWith((async e=>{const t=performance.now(),a=await async function(){return o||(console.log("perf: retrieving active cache name from db"),o=await n("local-version")),await caches.open("v1-"+o)}(),r=await a.match(e.request);if(r){const e=performance.now();return console.log("fast path perf: "+(e-t)),r}{const t=new URL(e.request.url).pathname;if(console.log(`file ${t} not in cache`),"/"==t){const e=await a.match("/index.html");if(e)return e}else if("/reinstall"==t){const e="v1-"+await n("local-version");console.log(`deleting cache ${e}`),console.log(await caches.delete(e)),await s("local-version",void 0),await i();const t=new Headers({Location:"/index.html"}),o=new Response("Done! Please go back to the main page now.",{status:307,statusText:"Redirecting back home",headers:t});return console.log("sent response with headers"),o}const o=new Headers({"Content-Type":"text/html"}),r=new Response('<!DOCTYPE html>\n<html>\n<head>\n<title>File not found</title>\n</head>\n<body>\n<p>The resource you requested was not in our cache. This could be for one of three reasons:</p>\n<ul>\n<li>The resource is part of the app, but we forgot to cache it. In this case, it would be nice if you filed an issue.</li>\n<li>The resource is part of the app, but the browser deleted it from our cache. In this case, please try <a href="/reinstall">re-downloading all relevant files</a>.</li>\n<li>The resource is not part of the app, but you or your browser decided to request it anyway. In this case, there is nothing we can do.</li>\n</ul>\n</body>\n</html>',{status:404,statusText:"Not Found",headers:o});return console.log("Warning: tried to fetch unpackaged resource: "+e.request.url),r}})(e).catch(e=>{console.log("cache lookup error: "+e+" ("+e.fileName+":"+e.lineNumber+")")}))}),self.addEventListener("message",async e=>{if("getversion"==e.data)e.source.postMessage({type:"version-info",serviceworker_version:"friday-lite-0.8"});else if("checkforupdates"==e.data){console.log("hello"),e.source.postMessage({type:"serviceworker-info",text:"Checking..."});try{await r(),e.source.postMessage({type:"serviceworker-info",text:""})}catch(t){e.source.postMessage({type:"serviceworker-info",text:`Sorry, couldn't check for updates. (Error: ${t})`}),console.log("Error in checkForUpdates: "+t+" ("+t.fileName+":"+t.lineNumber+")");const o=await n("update-available");e.source.postMessage({type:"update-info",status:o?"available":"up-to-date",date_checked:await n("date-checked"),update_size:await n("update-size")})}}else if("do-update"==e.data)try{await i()}catch(t){e.source.postMessage({type:"serviceworker-info",text:`Sorry, update failed. (Error: ${t})`}),console.log("Error in installNewestVersion: "+t+" ("+t.fileName+":"+t.lineNumber+")")}else if("get-update-info"==e.data){const t=await n("update-available");e.source.postMessage({type:"update-info",status:t?"available":"up-to-date",date_checked:await n("date-checked"),update_size:await n("update-size")})}})}();
//# sourceMappingURL=serviceworker-release.js.map
