!function(){"use strict";class e{constructor(e="keyval-store",t="keyval"){this.storeName=t,this._dbp=new Promise((o,n)=>{const a=indexedDB.open(e,1);a.onerror=()=>n(a.error),a.onsuccess=()=>o(a.result),a.onupgradeneeded=()=>{a.result.createObjectStore(t)}})}_withIDBStore(e,t){return this._dbp.then(o=>new Promise((n,a)=>{const s=o.transaction(this.storeName,e);s.oncomplete=()=>n(),s.onabort=s.onerror=()=>a(s.error),t(s.objectStore(this.storeName))}))}}let t,o;function n(){return t||(t=new e),t}function a(e,t=n()){let o;return t._withIDBStore("readonly",t=>{o=t.get(e)}).then(()=>o.result)}function s(e,t,o=n()){return o._withIDBStore("readwrite",o=>{o.put(t,e)})}async function r(){let e=performance.now();const t=await fetch("./version",{cache:"no-cache"});let o=performance.now();if(console.log(`perf: checkForUpdates: fetch took ${o-e}ms`),e=o,t.ok){console.log("reading version info...");let n=t.body.getReader();const r=await async function(e,t){e.next();for(;;){let{value:o,done:n}=await t.read();n&&e.throw("driveParserFromReader: endOfStream");for(let t of o){let o=e.next(t);if(o.done)return o.value}}}(function*(){const e=yield*d(),t=yield*function*(){const e=yield,t=yield,o=yield,n=yield;return e|t<<8|o<<16|n<<24}(),o=yield*l();console.log("reading "+o+" files");let n=[];for(let e=0;e<o;e++)n.push(yield*d());return{version:e,size:t,files:n}}(),n);console.log("version info parsed: "+JSON.stringify(r,null,2)),o=performance.now(),console.log(`perf: checkForUpdates: parsing took ${o-e}ms`),e=o;const i=r.version,u=await a("local-version"),f=new Date,p=u!=i;return await s("date-checked",f),await s("update-available",p),await s("update-size",r.size),console.log("local version: "+u+" / upstream version "+i),await c({type:"update-info",status:p?"available":"up-to-date",date_checked:f,update_size:r.size}),o=performance.now(),console.log(`perf: checkForUpdates: updating db and notifying clients took ${o-e}ms`),e=o,r}console.log("retrieving version file failed.")}async function i(){const e=performance.now();await c({type:"serviceworker-info",text:"Updating version info..."});const t=await r(),n=t.version,i=await a("local-version");if(console.log(`local_version: ${i}`),console.log(`upstream_version: ${n}`),i==n)return console.log("versions match, we're all good."),void await c({type:"serviceworker-info",text:"Huh, seems like your local version is already up-to-date..."});console.log("mismatch, updating."),await c({type:"serviceworker-info",text:"Downloading files..."});const l="v1-"+n,d="v1-"+i;await caches.delete(l);let u=await caches.open(l);try{for(const e of t.files){const t=await fetch("./versioned/"+n+"/"+e);await u.put(e,t)}}catch(e){throw await caches.delete(l),e}console.log("installNewestVersion: new cache's keys: "+await u.keys()),await c({type:"serviceworker-info",text:"Cleaning up..."}),await s("local-version",n),o=n,await caches.delete(d)?console.log("old cache deleted."):console.log("coulnd't find old cache??"),console.log("perf: installNewestVersion took "+(performance.now()-e)+"ms"),await c({type:"serviceworker-info",text:"Done! Your page should reload now."}),c({type:"update-info",status:"installed",last_checked:new Date})}async function c(e){const t=await clients.matchAll({type:"window"});console.log("notifyClients: posting message "+e+" to "+t.length+" clients.");for(const o of t)o.postMessage(e)}function*l(){return(yield)|(yield)<<8}function*d(){const e=yield*l();let t=new Uint8Array(e);for(let e=0;e<t.length;e++)t[e]=yield;return(new TextDecoder).decode(t)}self.addEventListener("install",e=>{e.waitUntil(async function(){await a("local-version")?await r():await i()}().catch(e=>console.log("Error in setup: "+e+" ("+e.fileName+":"+e.lineNumber+")")))}),self.addEventListener("fetch",e=>{e.respondWith((async e=>{const t=performance.now(),n=await async function(){return o||(console.log("perf: retrieving active cache name from db"),o=await a("local-version")),await caches.open("v1-"+o)}(),r=await n.match(e.request);if(r){const e=performance.now();return console.log("fast path perf: "+(e-t)),r}{const t=new URL(e.request.url).pathname,o=new URL(registration.scope).pathname;if(console.log(`file ${t} not in cache`),t==o){const e=await n.match("./index.html");if(e)return e}else if("reinstall"==t.split("/").slice(-1)[0]){const e="v1-"+await a("local-version");console.log(`deleting cache ${e}`),console.log(await caches.delete(e)),await s("local-version",void 0),await i();const t=new Headers({Location:o+"index.html"}),n=new Response("Done! Please go back to the main page now.",{status:307,statusText:"Redirecting back home",headers:t});return console.log("sent response with headers"),n}const r=new Headers({"Content-Type":"text/html"}),c=new Response('<!DOCTYPE html>\n<html>\n<head>\n<title>File not found</title>\n</head>\n<body>\n<p>The resource you requested was not in our cache. This could be for one of three reasons:</p>\n<ul>\n<li>The resource is part of the app, but we forgot to cache it. In this case, it would be nice if you filed an issue.</li>\n<li>The resource is part of the app, but the browser deleted it from our cache. In this case, please try <a href="./reinstall">re-downloading all relevant files</a>.</li>\n<li>The resource is not part of the app, but you or your browser decided to request it anyway. In this case, there is nothing we can do.</li>\n</ul>\n</body>\n</html>',{status:404,statusText:"Not Found",headers:r});return console.log("Warning: tried to fetch unpackaged resource: "+e.request.url),c}})(e).catch(e=>{console.log("cache lookup error: "+e+" ("+e.fileName+":"+e.lineNumber+")")}))}),self.addEventListener("message",async e=>{if("get-version"==e.data)e.source.postMessage({type:"version-info",serviceworker_version:"friday-lite-0.17"});else if("check-for-updates"==e.data){console.log("hello"),e.source.postMessage({type:"serviceworker-info",text:"Checking..."});try{await r(),e.source.postMessage({type:"serviceworker-info",text:""})}catch(t){e.source.postMessage({type:"serviceworker-info",text:`Sorry, couldn't check for updates. (Error: ${t})`}),console.log("Error in checkForUpdates: "+t+" ("+t.fileName+":"+t.lineNumber+")")}}else if("do-update"==e.data)try{await i()}catch(e){c({type:"serviceworker-info",text:`Sorry, update failed. (Error: ${e})`}),console.log("Error in installNewestVersion: "+e+" ("+e.fileName+":"+e.lineNumber+")")}else if("get-update-info"==e.data){const t=await a("update-available");e.source.postMessage({type:"update-info",status:t?"available":"up-to-date",date_checked:await a("date-checked"),update_size:await a("update-size")})}})}();
//# sourceMappingURL=serviceworker-release.js.map
