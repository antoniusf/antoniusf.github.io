!function(){"use strict";class e{constructor(e="keyval-store",t="keyval"){this.storeName=t,this._dbp=new Promise((o,n)=>{const a=indexedDB.open(e,1);a.onerror=()=>n(a.error),a.onsuccess=()=>o(a.result),a.onupgradeneeded=()=>{a.result.createObjectStore(t)}})}_withIDBStore(e,t){return this._dbp.then(o=>new Promise((n,a)=>{const r=o.transaction(this.storeName,e);r.oncomplete=()=>n(),r.onabort=r.onerror=()=>a(r.error),t(r.objectStore(this.storeName))}))}}let t,o;function n(){return t||(t=new e),t}function a(e,t=n()){let o;return t._withIDBStore("readonly",t=>{o=t.get(e)}).then(()=>o.result)}function r(e,t,o=n()){return o._withIDBStore("readwrite",o=>{o.put(t,e)})}const s=`<!DOCTYPE html>\n<html>\n<head>\n<title>File not found</title>\n</head>\n<body>\n<p>The resource you requested was not in our cache. This could be for one of three reasons:</p>\n<ul>\n<li>The resource is not part of the app, but you somehow just ended up here. In this case, maybe you'd just like to <a href="${registration.scope}">go back home</a>?</li>\n<li>The resource is part of the app, but we forgot to cache it. In this case, it would be nice if you filed an issue.</li>\n<li>The resource is part of the app, but something else went wrong. You may try <a href="./reinstall">re-downloading all relevant files</a> to fix this. Please be aware that this will clear the app's offline cache; if you are not connected to the internet, and you click this link, you will not be able to use the app again until you reconnect.</li>\n</ul>\n</body>\n</html>`;async function i(){let e=performance.now();const t=await fetch("./version",{cache:"no-cache"});let o=performance.now();if(console.log(`perf: checkForUpdates: fetch took ${o-e}ms`),e=o,t.ok){console.log("reading version info...");let n=t.body.getReader();const s=await async function(e,t){e.next();for(;;){let{value:o,done:n}=await t.read();n&&e.throw("driveParserFromReader: endOfStream");for(let t of o){let o=e.next(t);if(o.done)return o.value}}}(function*(){const e=yield*u(),t=yield*function*(){const e=yield,t=yield,o=yield,n=yield;return e|t<<8|o<<16|n<<24}(),o=yield*d();console.log("reading "+o+" files");let n=[];for(let e=0;e<o;e++)n.push(yield*u());return{version:e,size:t,files:n}}(),n);console.log("version info parsed: "+JSON.stringify(s,null,2)),o=performance.now(),console.log(`perf: checkForUpdates: parsing took ${o-e}ms`),e=o;const i=s.version,l=await a("local-version"),h=new Date,p=l!=i;return await r("date-checked",h),await r("update-available",p),await r("update-size",s.size),await r("upstream-version",i),console.log("local version: "+l+" / upstream version "+i),await c({type:"update-info",status:p?"available":"up-to-date",date_checked:h,update_size:s.size,new_version:i,current_version:l}),o=performance.now(),console.log(`perf: checkForUpdates: updating db and notifying clients took ${o-e}ms`),e=o,s}console.log("retrieving version file failed.")}async function l(){const e=performance.now();await c({type:"serviceworker-info",text:"Updating version info..."});const t=await i(),n=t.version,s=await a("local-version");if(console.log("local_version: "+s),console.log("upstream_version: "+n),s==n)return console.log("versions match, we're all good."),void await c({type:"serviceworker-info",text:"Huh, seems like your local version is already up-to-date..."});console.log("mismatch, updating."),await c({type:"serviceworker-info",text:"Downloading files..."});const l="v1-"+n,d="v1-"+s;await caches.delete(l);let u=await caches.open(l);try{for(const e of t.files){const t=await fetch("./versioned/"+n+"/"+e);await u.put(e,t)}}catch(e){throw await caches.delete(l),e}console.log("installNewestVersion: new cache's keys: "+await u.keys()),await c({type:"serviceworker-info",text:"Cleaning up..."}),await r("local-version",n),o=n,await caches.delete(d)?console.log("old cache deleted."):console.log("coulnd't find old cache??"),console.log("perf: installNewestVersion took "+(performance.now()-e)+"ms"),await c({type:"serviceworker-info",text:"Done! Your page should reload now."}),c({type:"update-info",status:"installed",last_checked:new Date,current_version:n})}async function c(e){const t=await clients.matchAll({type:"window"});console.log("notifyClients: posting message "+e+" to "+t.length+" clients.");for(const o of t)o.postMessage(e)}function*d(){return(yield)|(yield)<<8}function*u(){const e=yield*d();let t=new Uint8Array(e);for(let e=0;e<t.length;e++)t[e]=yield;return(new TextDecoder).decode(t)}self.addEventListener("install",e=>{e.waitUntil(async function(){await a("local-version")?await i():await l()}().catch(e=>console.log("Error in setup: "+e+" ("+e.fileName+":"+e.lineNumber+")")))}),self.addEventListener("fetch",e=>{e.respondWith((async e=>{const t=performance.now(),n=await async function(){return o||(console.log("perf: retrieving active cache name from db"),o=await a("local-version")),await caches.open("v1-"+o)}(),i=await n.match(e.request);if(i){const e=performance.now();return console.log("fast path perf: "+(e-t)),i}{const t=new URL(e.request.url).pathname,o=new URL(registration.scope).pathname;if(console.log(`file ${t} not in cache`),t==o){const e=await n.match("./index.html");if(e)return e}else if("reinstall"==t.split("/").slice(-1)[0]){const e="v1-"+await a("local-version");console.log("deleting cache "+e),console.log(await caches.delete(e)),await r("local-version",void 0);try{await l();const e=new Headers({Location:o+"index.html"});return new Response("Done! Please go back to the main page now.",{status:307,statusText:"Redirecting back home",headers:e})}catch(e){const t=new Headers({"Content-Type":"text/html"});return new Response((e=>`<!DOCTYPE html>\n<html>\n<head>\n<title>Reinstallation failed</title>\n</head>\n<body>\n<p>Sorry, an error occured while we tried to reinstall your app. (${e})</p><p>This might be because you are not connected to the internet right now. If this is the case, please reconnect and reload this page.</p>\n</body>\n</html>`)(e),{status:200,statusText:"no",headers:t})}}const i=new Headers({"Content-Type":"text/html"}),c=new Response(s,{status:404,statusText:"Not Found",headers:i});return console.log("Warning: tried to fetch unpackaged resource: "+e.request.url),c}})(e).catch(e=>{console.log("cache lookup error: "+e+" ("+e.fileName+":"+e.lineNumber+")")}))}),self.addEventListener("message",async e=>{if("get-version"==e.data)e.source.postMessage({type:"version-info",serviceworker_version:"friday-lite-0.24"});else if("check-for-updates"==e.data){e.source.postMessage({type:"serviceworker-info",text:"Checking..."});try{await i(),e.source.postMessage({type:"serviceworker-info",text:""})}catch(t){e.source.postMessage({type:"serviceworker-info",text:`Sorry, couldn't check for updates. (Error: ${t})`}),console.log("Error in checkForUpdates: "+t+" ("+t.fileName+":"+t.lineNumber+")")}}else if("do-update"==e.data)try{await l()}catch(e){c({type:"serviceworker-info",text:`Sorry, update failed. (Error: ${e})`}),console.log("Error in installNewestVersion: "+e+" ("+e.fileName+":"+e.lineNumber+")")}else if("get-update-info"==e.data){const t=await a("update-available");e.source.postMessage({type:"update-info",status:t?"available":"up-to-date",date_checked:await a("date-checked"),update_size:await a("update-size"),new_version:await a("upstream-version"),current_version:await a("local-version")})}})}();
//# sourceMappingURL=serviceworker-release.js.map
